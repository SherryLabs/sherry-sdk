## <<<<<<< HEAD

description: Guía completa paso a paso para construir mini apps dinámicas usando Next.js y el Sherry Links SDK
sidebar_position: 1
tags: [nextjs, sdk, mini-apps, blockchain, tutorial]

---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import Admonition from '@theme/Admonition';

# Guía - MiniApp con NextJS

## Creando Mini Apps con Next.js y Sherry SDK

Esta guía completa te enseñará paso a paso cómo crear mini apps potentes usando **Next.js** y el **Sherry Links SDK**. Las mini apps son aplicaciones dinámicas que pueden integrarse en diferentes plataformas y permiten a los usuarios interactuar con contratos inteligentes de manera fluida.

<Admonition type="info" title="Información del Minithon">
  Este tutorial contiene notas específicas para **participantes del hackathon Minithon**. Si el
  Minithon ya ha concluido, puedes ignorar estas referencias - todo el contenido técnico y ejemplos
  siguen siendo completamente aplicables para aprender y probar acciones dinámicas en producción.
</Admonition>

<Admonition type="warning" title="Importante para Participantes del Minithon">
  Este tutorial progresa desde un **ejemplo básico** (transferencia simple) hasta un **ejemplo
  complejo** (interacción con contratos inteligentes). Para envíos al minithon, necesitarás
  implementar la versión compleja que interactúa con contratos inteligentes, ya que las
  transferencias simples ya pueden manejarse con nuestro TransferAction incorporado.
</Admonition>

## 📋 Tabla de Contenidos

- [Cómo Funciona Sherry - Entendiendo el Flujo](#🔄-cómo-funciona-sherry---entendiendo-el-flujo)
- [Requisitos Previos](#🛠️-requisitos-previos)
- [Configuración Inicial](#🏗️-configuración-inicial)
- [Creando el Endpoint GET - Metadata](#🎯-creando-el-endpoint-get---metadata)
- [Ejemplo 1: Transferencia Simple (Solo Aprendizaje)](#📚-ejemplo-1-transferencia-simple-solo-aprendizaje)
- [Ejemplo 2: Interacción con Contratos Inteligentes (Listo para Minithon)](#🎯-ejemplo-2-interacción-con-contratos-inteligentes-listo-para-minithon)
- [Manejo de CORS](#🌐-manejo-de-cors)
- [Probando tu Mini App](#🧪-probando-tu-mini-app)
- [Guías del Minithon](#🏆-guías-del-minithon)
- [Resolución de Problemas](#🔧-resolución-de-problemas)
- [Ejemplo de Código Completo](#🚀-ejemplo-de-código-completo)
- [Repositorio de Ejemplos](#📚-repositorio-de-ejemplos)
- [Próximos Pasos](#🎯-próximos-pasos)

## 🔄 Cómo Funciona Sherry - Entendiendo el Flujo

Antes de empezar a construir, es importante entender cómo Sherry Links conecta usuarios, plataformas y tu backend de mini app. El siguiente diagrama ilustra el flujo completo:

<div style={{ textAlign: 'center', margin: '2rem 0' }}>
  <img
    src="/img/sherry-flow.png"
    alt="Diagrama de Flujo de Sherry Links - Cómo los usuarios interactúan con mini apps a través de la plataforma"
    style={{
      maxWidth: '100%',
      height: 'auto',
      border: '1px solid var(--ifm-color-emphasis-300)',
      borderRadius: '8px',
      boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
    }}
  />
</div>

### Flujo Paso a Paso

1. **Sherry hace petición GET y recibe metadata**

   - La plataforma descubre tu mini app y solicita su configuración
   - Tu backend responde con metadata que define la UI y funcionalidad

2. **Back-End retorna metadata**

   - La metadata incluye campos de formulario, botones de acción, descripciones y endpoints
   - Esto le dice a Sherry cómo renderizar la interfaz de tu mini app

3. **Sherry renderiza mini-app**

   - La plataforma crea un formulario amigable basado en tu metadata
   - Los usuarios pueden ver campos de entrada, descripciones y botones de acción

4. **Usuario ejecuta mini-app**

   - El usuario llena el formulario con sus parámetros deseados
   - El usuario hace clic en el botón de acción para enviar su solicitud

5. **Sherry hace petición POST y recibe transacción serializada desde Back-End**

   - La plataforma envía la entrada del usuario a tu backend para procesamiento
   - Tu backend aplica lógica personalizada y retorna una transacción blockchain lista para firmar

6. **Usuario confirma transacción**
   - El usuario revisa los detalles de la transacción en su wallet
   - El usuario firma y envía la transacción a la blockchain

<Admonition type="tip" title="Concepto Clave">
  Tu mini app actúa como una **fábrica inteligente de transacciones** - toma la entrada del usuario,
  aplica tu lógica de negocio única, y produce transacciones blockchain listas para firmar. Esto es
  lo que hace poderoso a Sherry Links: combinar gran UX con funcionalidad blockchain personalizada.
</Admonition>

## 🛠️ Requisitos Previos

Antes de comenzar, asegúrate de tener lo siguiente instalado y configurado:

- **Node.js**: Versión 18.x o superior
- **Gestor de Paquetes**: npm, yarn, o pnpm
- **Conocimiento del Framework**: Conceptos básicos de Next.js y TypeScript
- **Conceptos Básicos de Blockchain**: Entendimiento de contratos inteligentes y ABI

## 🏗️ Configuración Inicial

### 1. Crear Proyecto Next.js

<Tabs>
<TabItem value="npm" label="npm" default>
=======
# Creando Mini Apps con Next.js y Sherry SDK

<iframe
  style={{ width: '100%', aspectRatio: '16 / 9', border: 'none' }}
  src="https://www.youtube.com/embed/oHmoJUOgLBA"
  title="YouTube video player"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen
></iframe>

Esta guía te enseñará paso a paso cómo crear una mini app utilizando Next.js y
el SDK de Sherry Links. Las mini apps son aplicaciones dinámicas que pueden ser
integradas en diferentes plataformas y permiten a los usuarios interactuar con
contratos inteligentes de manera sencilla.

## Tabla de Contenidos

1. [Requisitos Previos](#requisitos-previos)
2. [Configuración Inicial](#configuración-inicial)
3. [Creando el Endpoint GET - Metadata](#creando-el-endpoint-get---metadata)
4. [Creando el Endpoint POST - Ejecución](#creando-el-endpoint-post---ejecución)
5. [Manejo de CORS](#manejo-de-cors)
6. [Probando tu Mini App](#probando-tu-mini-app)
7. [Resolución de Problemas](#resolución-de-problemas)

## Requisitos Previos

- Node.js (versión 18.x o superior)
- npm, yarn o pnpm
- Conocimientos básicos de Next.js y TypeScript
- Cuenta en una plataforma blockchain (para pruebas)

## Configuración Inicial

### 1. Crear el Proyecto Next.js

> > > > > > > develop

```bash
npx create-next-app@latest mi-sherry-app --typescript --eslint --tailwind --src-dir --app --import-alias "@/*"
cd mi-sherry-app
```

<<<<<<< HEAD

</TabItem>
<TabItem value="yarn" label="yarn">

```bash
yarn create next-app mi-sherry-app --typescript --eslint --tailwind --src-dir --app --import-alias "@/*"
cd mi-sherry-app
```

</TabItem>
<TabItem value="pnpm" label="pnpm">

```bash
pnpm create next-app mi-sherry-app --typescript --eslint --tailwind --src-dir --app --import-alias "@/*"
cd mi-sherry-app
```

</TabItem>
</Tabs>

### 2. Instalar Dependencias

<Tabs>
<TabItem value="npm" label="npm" default>

=======

### 2. Instalar Dependencias

> > > > > > > develop

```bash
npm install @sherrylinks/sdk viem wagmi
```

<<<<<<< HEAD

</TabItem>
<TabItem value="yarn" label="yarn">

```bash
yarn add @sherrylinks/sdk viem wagmi
```

</TabItem>
<TabItem value="pnpm" label="pnpm">

```bash
pnpm add @sherrylinks/sdk viem wagmi
```

</TabItem>
</Tabs>

### 3. Configurar Next.js (Opcional)

<Admonition type="tip" title="Optimización de Build">
  Para evitar errores de build con ESLint, puedes deshabilitarlo en `next.config.js`:
</Admonition>

````javascript title="next.config.js"
=======
### 3. Configurar Next.js (Opcional)

Para evitar errores de build con ESLint, puedes deshabilitarlo en
`next.config.js`:

```javascript
>>>>>>> develop
/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: {
    ignoreDuringBuilds: true,
  },
};

module.exports = nextConfig;
````

<<<<<<< HEAD

## 🎯 Creando el Endpoint GET - Metadata

El endpoint GET es el **corazón** de tu mini app. Aquí defines toda la información y estructura que las plataformas necesitan para renderizar tu aplicación.

<Admonition type="note" title="Entendiendo la Metadata">
  La metadata le dice a las plataformas **cómo** renderizar tu mini app, **qué** inputs mostrar a
  los usuarios, y **dónde** enviar los datos cuando los usuarios interactúan con ella.
</Admonition>
======= ## Creando el Endpoint GET - Metadata

El endpoint GET es el corazón de tu mini app. Aquí defines toda la información y
estructura que las plataformas necesitan para renderizar tu aplicación.

> > > > > > > develop

### 1. Crear el Archivo de Ruta

Crea el archivo `app/api/mi-app/route.ts`:

<<<<<<< HEAD

````typescript title="app/api/mi-app/route.ts"
=======
```typescript
>>>>>>> develop
import { NextRequest, NextResponse } from 'next/server';
import { createMetadata, Metadata, ValidatedMetadata } from '@sherrylinks/sdk';
````

<<<<<<< HEAD

### 2. Configurar la Estructura Básica del Handler GET

```typescript
export async function GET(req: NextRequest) {
  try {
    // Obtener información de la URL del servidor
    const host = req.headers.get('host') || 'localhost:3000';
    const protocol = req.headers.get('x-forwarded-proto') || 'http';

    // Construir la URL base
    const serverUrl = `${protocol}://${host}`;

    // Construiremos el objeto metadata paso a paso abajo
  } catch (error) {
    console.error('Error creando metadata:', error);
    return NextResponse.json({ error: 'Error al crear metadata' }, { status: 500 });
  }
}
```

<Admonition type="info" title="¿Por qué serverUrl?">
  Esto detecta automáticamente si estás ejecutando localmente (`http://localhost:3000`) o en
  producción (`https://tudominio.com`) y construye la URL base correcta para tu mini app.
</Admonition>

### 3. Definir Información Básica de la App

```typescript
export async function GET(req: NextRequest) {
  try {
    const host = req.headers.get('host') || 'localhost:3000';
    const protocol = req.headers.get('x-forwarded-proto') || 'http';
    const serverUrl = `${protocol}://${host}`;

    const metadata: Metadata = {
      url: 'https://sherry.social',
      icon: 'https://avatars.githubusercontent.com/u/117962315',
      title: 'Mensaje con Timestamp',
      baseUrl: serverUrl,
      description:
        'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
      // Las acciones se agregarán en el siguiente paso
    };
  } catch (error) {
    // Manejo de errores...
  }
}
```

<details>
<summary><strong>Entendiendo Cada Campo</strong></summary>

| Campo           | Descripción                                                      | Ejemplo                                           |
| --------------- | ---------------------------------------------------------------- | ------------------------------------------------- |
| **url**         | URL principal del sitio web de tu proyecto                       | `"https://sherry.social"`                         |
| **icon**        | URL de imagen públicamente accesible (200x200px recomendado)     | `"https://ejemplo.com/icon.png"`                  |
| **title**       | Nombre corto y descriptivo para tu mini app                      | `"Mensaje con Timestamp"`                         |
| **baseUrl**     | URL del servidor donde tu mini app está alojada (auto-detectada) | `"https://tudominio.com"`                         |
| **description** | Explicación clara de qué hace tu mini app                        | `"Almacenar mensajes con timestamps optimizados"` |

</details>

### 4. Agregar Array de Acciones

<Admonition type="caution" title="Las Acciones Definen la Funcionalidad">
  Las acciones definen **qué pueden hacer** los usuarios con tu mini app. Cada acción representa un
  botón con funcionalidad específica.
</Admonition>

````typescript
const metadata: Metadata = {
  url: 'https://sherry.social',
  icon: 'https://avatars.githubusercontent.com/u/117962315',
  title: 'Mensaje con Timestamp',
  baseUrl: serverUrl,
  description: 'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
  actions: [
    {
      type: 'dynamic',
      label: 'Almacenar Mensaje',
      description:
        'Almacena tu mensaje con un timestamp personalizado calculado para almacenamiento óptimo',
      chains: { source: 'fuji' },
      path: `/api/mi-app`,
      // Los parámetros se agregarán en el siguiente paso
=======
### 2. Configurar la Información General

Comencemos definiendo la información básica de tu mini app:

```typescript
export async function GET(req: NextRequest) {
    try {
        // Obtener la URL base del servidor
        const host = req.headers.get('host') || 'localhost:3000';
        const protocol = req.headers.get('x-forwarded-proto') || 'http';
        const serverUrl = `${protocol}://${host}`;

        const metadata: Metadata = {
            url: "https://tu-sitio-web.com", // URL de tu sitio web principal
            icon: "https://tu-sitio-web.com/icon.png", // URL del ícono de tu app
            title: "Mi Mini App", // Título que aparecerá en las plataformas
            baseUrl: serverUrl, // URL base donde está hospedada tu app
            description: "Descripción detallada de lo que hace tu mini app",
            // Las acciones las definiremos en el siguiente paso
        };
    }
}
````

#### Explicación de Campos Generales:

- **url**: URL de tu sitio web o documentación principal
- **icon**: Imagen que representará tu mini app (debe ser accesible
  públicamente)
- **title**: Nombre corto y descriptivo de tu aplicación
- **baseUrl**: URL donde está corriendo tu aplicación (se construye
  automáticamente)
- **description**: Explicación clara de qué hace tu mini app

### 3. Definir las Acciones

Ahora vamos a agregar las acciones que los usuarios pueden realizar:

```typescript
const metadata: Metadata = {
  // ... información general anterior ...
  actions: [
    {
      type: 'dynamic', // Tipo de acción (siempre "dynamic" para mini apps)
      label: 'Ejecutar Acción', // Texto que aparecerá en el botón
      description: 'Descripción de lo que hace esta acción específica',
      chains: {
        source: 'fuji', // Blockchain donde se ejecutará (fuji = Avalanche Fuji Testnet)
      },
      path: `/api/mi-app`, // Ruta del endpoint POST que manejará la ejecución
      // Los parámetros los definiremos en el siguiente paso
>>>>>>> develop
    },
  ],
};
```

<<<<<<< HEAD

<details>
<summary><strong>Entendiendo las Propiedades de Acción</strong></summary>

- **type**: Siempre usa `"dynamic"` para mini apps complejas que necesitan lógica personalizada
- **label**: El texto que aparecerá en el botón de acción
- **description**: Explicación de qué hace esta acción específica
- **chains.source**: La blockchain donde se ejecutará la transacción
  - `"fuji"` = Avalanche Fuji Testnet
  - `"avalanche"` = Avalanche Mainnet
- **path**: El endpoint de API que manejará la petición POST

</details>

### 5. Configurar Parámetros de Entrada del Usuario

````typescript
const metadata: Metadata = {
  url: 'https://sherry.social',
  icon: 'https://avatars.githubusercontent.com/u/117962315',
  title: 'Mensaje con Timestamp',
  baseUrl: serverUrl,
  description: 'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
  actions: [
    {
      type: 'dynamic',
      label: 'Almacenar Mensaje',
      description:
        'Almacena tu mensaje con un timestamp personalizado calculado para almacenamiento óptimo',
      chains: { source: 'fuji' },
      path: `/api/mi-app`,
      params: [
        {
          name: 'mensaje',
          label: '¡Tu Mensaje Hermano!',
          type: 'text',
          required: true,
          description: 'Ingresa el mensaje que quieres almacenar en la blockchain',
=======
#### Explicación de Campos de Acción:

- **type**: Siempre debe ser "dynamic" para mini apps
- **label**: Texto del botón que verán los usuarios
- **description**: Explicación de qué hace esta acción
- **chains.source**: Nombre de la blockchain (ej: "fuji", "ethereum", "polygon")
- **path**: Ruta de tu endpoint POST que ejecutará la acción

### 4. Configurar Parámetros

Los parámetros son los datos que el usuario debe proporcionar. Si no tienen un
valor predeterminado, se renderizará un input:

```typescript
const metadata: Metadata = {
  // ... información anterior ...
  actions: [
    {
      // ... configuración anterior ...
      params: [
        {
          name: 'mensaje', // Nombre del parámetro (se usará como query param)
          label: 'Tu Mensaje', // Etiqueta que verá el usuario
          type: 'text', // Tipo de input (text, number, email, etc.)
          required: true, // Si es obligatorio o no
          description: 'Ingresa el mensaje que quieres guardar en la blockchain',
        },
        {
          name: 'cantidad',
          label: 'Cantidad (ETH)',
          type: 'number',
          required: false,
          description: 'Cantidad en ETH (opcional)',
>>>>>>> develop
        },
      ],
    },
  ],
};
````

<<<<<<< HEAD

<Admonition type="info" title="Tipos de Parámetros Disponibles">
  - `"text"`: Entrada de texto de una línea - `"textarea"`: Entrada de texto multilínea -
  `"number"`: Entrada numérica con validación - `"email"`: Entrada de email con validación -
  `"url"`: Entrada de URL con validación
</Admonition>

### 6. Validar y Retornar la Metadata

=======

#### Tipos de Parámetros Disponibles:

- **text**: Campo de texto libre
- **number**: Solo números
- **email**: Validación de email
- **url**: Validación de URL
- **password**: Campo de contraseña
- **textarea**: Texto largo

### 5. Validar y Retornar la Metadata

> > > > > > > develop

```typescript
export async function GET(req: NextRequest) {
  try {
<<<<<<< HEAD
    const host = req.headers.get('host') || 'localhost:3000';
    const protocol = req.headers.get('x-forwarded-proto') || 'http';
    const serverUrl = `${protocol}://${host}`;

    const metadata: Metadata = {
      url: 'https://sherry.social',
      icon: 'https://avatars.githubusercontent.com/u/117962315',
      title: 'Mensaje con Timestamp',
      baseUrl: serverUrl,
      description:
        'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
      actions: [
        {
          type: 'dynamic',
          label: 'Almacenar Mensaje',
          description:
            'Almacena tu mensaje con un timestamp personalizado calculado para almacenamiento óptimo',
          chains: { source: 'fuji' },
          path: `/api/mi-app`,
          params: [
            {
              name: 'mensaje',
              label: '¡Tu Mensaje Hermano!',
              type: 'text',
              required: true,
              description: 'Ingresa el mensaje que quieres almacenar en la blockchain',
            },
          ],
        },
      ],
    };

    // Validar metadata usando el SDK
    const validated: ValidatedMetadata = createMetadata(metadata);

    // Retornar con headers CORS para acceso cross-origin
=======
    // ... construcción de metadata anterior ...

    // Validar la metadata usando el SDK
    const validated: ValidatedMetadata = createMetadata(metadata);

    // Retornar con headers CORS
>>>>>>> develop
    return NextResponse.json(validated, {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      },
    });
  } catch (error) {
    console.error('Error creando metadata:', error);
<<<<<<< HEAD
    return NextResponse.json({ error: 'Error al crear metadata' }, { status: 500 });
=======
    return NextResponse.json(
      { error: 'Error al crear metadata' },
      {
        status: 500,
      },
    );
>>>>>>> develop
  }
}
```

<<<<<<< HEAD

<Admonition type="success" title="Beneficios de la Validación">
  La función `createMetadata()` valida la estructura de tu metadata y asegura que cumple con los
  requisitos del Sherry SDK antes de retornarla a la plataforma.
</Admonition>

## 📚 Ejemplo 1: Transferencia Simple (Solo Aprendizaje)

<Admonition type="danger" title="Nota Importante">
  Este ejemplo es para **aprender los conceptos básicos solamente**. Transferencias simples como
  esta ya están soportadas por nuestro TransferAction incorporado y **NO serán aceptadas** en envíos
  al minithon. Úsalo para entender el flujo, luego pasa al Ejemplo 2 para funcionalidad lista para
  minithon.
</Admonition>

### Entendiendo el Flujo de Petición POST

Cuando un usuario completa el formulario de tu mini app y hace clic en el botón de acción, la plataforma enviará una **petición POST** a tu endpoint con la entrada del usuario como parámetros de URL.

### 1. Configurar la Estructura del Handler POST

Agrega estas importaciones al inicio de tu archivo:

```typescript title="app/api/mi-app/route.ts"
import { NextRequest, NextResponse } from 'next/server';
import { avalancheFuji } from 'viem/chains';
import { createMetadata, Metadata, ValidatedMetadata, ExecutionResponse } from '@sherrylinks/sdk';
import { serialize } from 'wagmi';
```

Ahora construyamos el handler POST:

<Tabs>
<TabItem value="basic" label="Estructura Básica" default>

```typescript
export async function POST(req: NextRequest) {
  try {
    // Paso 1: Extraer parámetros de la URL
    const { searchParams } = new URL(req.url);
    const mensaje = searchParams.get('mensaje');

    // Agregaremos validación y creación de transacción abajo
  } catch (error) {
    console.error('Error en petición POST:', error);
    return NextResponse.json({ error: 'Error Interno del Servidor' }, { status: 500 });
  }
}
```

</TabItem>
<TabItem value="validation" label="Con Validación">

```typescript
export async function POST(req: NextRequest) {
  try {
    // Extraer parámetros
    const { searchParams } = new URL(req.url);
    const mensaje = searchParams.get('mensaje');

    // Validar parámetros requeridos
    if (!mensaje) {
      return NextResponse.json(
        { error: 'El parámetro mensaje es requerido' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    // La creación de transacción se agregará después
  } catch (error) {
    // Manejo de errores...
  }
}
```

</TabItem>
</Tabs>

### 2. Crear el Objeto de Transacción

```typescript
// Crear una transacción de transferencia simple
const tx = {
  to: '0x5ee75a1B1648C023e885E58bD3735Ae273f2cc52',
  value: BigInt(1000000), // 1000000 wei = 0.000001 AVAX
  chainId: avalancheFuji.id,
};
```

<details>
<summary><strong>Entendiendo las Propiedades de Transacción</strong></summary>

- **to**: La dirección de destino que recibirá la transferencia
- **value**: La cantidad a transferir en wei (unidad más pequeña). Usa `BigInt()` para números grandes
- **chainId**: El ID numérico de la blockchain (avalancheFuji.id = 43113)

</details>

### 3. Ejemplo Completo de Transferencia Simple

```typescript title="Handler POST Completo - Transferencia Simple"
export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const mensaje = searchParams.get('mensaje');

    if (!mensaje) {
      return NextResponse.json(
        { error: 'El parámetro mensaje es requerido' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    const tx = {
      to: '0x5ee75a1B1648C023e885E58bD3735Ae273f2cc52',
      value: BigInt(1000000),
      chainId: avalancheFuji.id,
    };

    // Serializar la transacción para la blockchain
    const serialized = serialize(tx);

    // Crear el objeto de respuesta que Sherry espera
    const resp: ExecutionResponse = {
      serializedTransaction: serialized,
      chainId: avalancheFuji.name, // Usar el nombre de la chain, no el ID
    };

    // Retornar la respuesta con headers CORS
    return NextResponse.json(resp, {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    });
  } catch (error) {
    console.error('Error en petición POST:', error);
    return NextResponse.json({ error: 'Error Interno del Servidor' }, { status: 500 });
  }
}
```

<Admonition type="warning" title="Por Qué Esto No Es Listo para Minithon">
  Este ejemplo solo realiza una transferencia simple de tokens. Dado que nuestra plataforma ya
  proporciona **TransferAction** para esta funcionalidad exacta, los envíos al minithon necesitan
  demostrar funcionalidad más compleja y con valor agregado.
</Admonition>

## 🎯 Ejemplo 2: Interacción con Contratos Inteligentes (Listo para Minithon)

<Admonition type="success" title="Adecuado para Minithon">
  Este ejemplo demuestra **interacción con contratos inteligentes** con lógica de negocio
  personalizada, que es lo que buscamos en los envíos al minithon.
</Admonition>

### 1. Entendiendo el Contrato Inteligente

Primero, entendamos qué hace nuestro contrato inteligente:

```solidity title="Contrato TimestampedMessage"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title TimestampedMessage
 * @dev Stores messages with an optimized timestamp
 */
contract TimestampedMessage {
    event MessageStored(address indexed sender, string message, uint256 timestamp, uint256 optimizedTimestamp);

    struct MessageData {
        address sender;
        string message;
        uint256 timestamp;
        uint256 optimizedTimestamp;
    }

    // Array to store all messages
    MessageData[] public messages;

    // Mapping from address to their message count
    mapping(address => uint256) public userMessageCount;

    /**
     * @dev Store a message with an optimized timestamp
     * @param message The message to store
     * @param optimizedTimestamp A timestamp calculated off-chain
     */
    function storeMessage(string memory message, uint256 optimizedTimestamp) public {
        // Store message with the current block timestamp and the optimized timestamp
        messages.push(MessageData({
            sender: msg.sender,
            message: message,
            timestamp: block.timestamp,
            optimizedTimestamp: optimizedTimestamp
        }));

        // Increment message count for the sender
        userMessageCount[msg.sender]++;

        // Emit event
        emit MessageStored(msg.sender, message, block.timestamp, optimizedTimestamp);
    }

    /**
     * @dev Get the count of all messages
     */
    function getMessageCount() public view returns (uint256) {
        return messages.length;
    }

    /**
     * @dev Get a message by index
     */
    function getMessage(uint256 index) public view returns (
        address sender,
        string memory message,
        uint256 timestamp,
        uint256 optimizedTimestamp
    ) {
        require(index < messages.length, "Index out of bounds");
        MessageData memory data = messages[index];
        return (data.sender, data.message, data.timestamp, data.optimizedTimestamp);
    }

    /**
     * @dev Get all messages from a specific sender
     */
    function getMessagesBySender(address sender) public view returns (
        string[] memory messageTexts,
        uint256[] memory timestamps,
        uint256[] memory optimizedTimestamps
    ) {
        uint256 count = userMessageCount[sender];

        messageTexts = new string[](count);
        timestamps = new uint256[](count);
        optimizedTimestamps = new uint256[](count);

        uint256 currentIndex = 0;

        for (uint256 i = 0; i < messages.length; i++) {
            if (messages[i].sender == sender) {
                messageTexts[currentIndex] = messages[i].message;
                timestamps[currentIndex] = messages[i].timestamp;
                optimizedTimestamps[currentIndex] = messages[i].optimizedTimestamp;
                currentIndex++;
            }
        }

        return (messageTexts, timestamps, optimizedTimestamps);
    }
}
```

<Admonition type="info" title="Por Qué Esto Es Listo para Minithon">
  - Lógica de negocio personalizada (cálculo de timestamp optimizado) - Gestión de estado de
  contrato inteligente - Emisión de eventos para seguimiento - Estructuras de datos complejas - Va
  más allá de transferencias simples
</Admonition>

### 2. Configurar el ABI del Contrato

<Admonition type="warning" title="Paso Crucial">
  El **ABI (Application Binary Interface)** es esencial para interactuar con contratos inteligentes.
  Define las funciones disponibles, sus parámetros y tipos de retorno. Sin el ABI correcto, no
  podrás codificar las llamadas a funciones del contrato.
</Admonition>

Crea el archivo `blockchain/abi.ts` en tu proyecto:

```typescript title="blockchain/abi.ts"
export const abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: 'address',
        name: 'sender',
        type: 'address',
      },
      {
        indexed: false,
        internalType: 'string',
        name: 'message',
        type: 'string',
      },
      {
        indexed: false,
        internalType: 'uint256',
        name: 'timestamp',
        type: 'uint256',
      },
      {
        indexed: false,
        internalType: 'uint256',
        name: 'optimizedTimestamp',
        type: 'uint256',
      },
    ],
    name: 'MessageStored',
    type: 'event',
  },
  {
    inputs: [
      {
        internalType: 'string',
        name: 'message',
        type: 'string',
      },
      {
        internalType: 'uint256',
        name: 'optimizedTimestamp',
        type: 'uint256',
      },
    ],
    name: 'storeMessage',
    outputs: [],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [
      {
        internalType: 'uint256',
        name: 'index',
        type: 'uint256',
      },
    ],
    name: 'getMessage',
    outputs: [
      {
        internalType: 'address',
        name: 'sender',
        type: 'address',
      },
      {
        internalType: 'string',
        name: 'message',
        type: 'string',
      },
      {
        internalType: 'uint256',
        name: 'timestamp',
        type: 'uint256',
      },
      {
        internalType: 'uint256',
        name: 'optimizedTimestamp',
        type: 'uint256',
      },
    ],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'getMessageCount',
    outputs: [
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256',
      },
    ],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: 'sender',
        type: 'address',
      },
    ],
    name: 'getMessagesBySender',
    outputs: [
      {
        internalType: 'string[]',
        name: 'messageTexts',
        type: 'string[]',
      },
      {
        internalType: 'uint256[]',
        name: 'timestamps',
        type: 'uint256[]',
      },
      {
        internalType: 'uint256[]',
        name: 'optimizedTimestamps',
        type: 'uint256[]',
      },
    ],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256',
      },
    ],
    name: 'messages',
    outputs: [
      {
        internalType: 'address',
        name: 'sender',
        type: 'address',
      },
      {
        internalType: 'string',
        name: 'message',
        type: 'string',
      },
      {
        internalType: 'uint256',
        name: 'timestamp',
        type: 'uint256',
      },
      {
        internalType: 'uint256',
        name: 'optimizedTimestamp',
        type: 'uint256',
      },
    ],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [
      {
        internalType: 'address',
        name: '',
        type: 'address',
      },
    ],
    name: 'userMessageCount',
    outputs: [
      {
        internalType: 'uint256',
        name: '',
        type: 'uint256',
      },
    ],
    stateMutability: 'view',
    type: 'function',
  },
] as const;
```

<Admonition type="tip" title="Cómo Obtener el ABI">
  - **Remix**: Después de compilar, ve a la pestaña `solidity compiler`y busca el texto `ABI` al final.
  - **Hardhat**: Se genera automáticamente en `artifacts/contracts/`
  - **Foundry**: Usa `forge inspect <ContractName> abi`
  - **Explorador de Blockchain**: Si el contrato está verificado, puedes copiar el ABI
</Admonition>

### 3. Actualizar las Importaciones de tu Archivo de Ruta

```typescript title="app/api/mi-app/route.ts"
import { NextRequest, NextResponse } from 'next/server';
import { avalancheFuji } from 'viem/chains';
import { createMetadata, Metadata, ValidatedMetadata, ExecutionResponse } from '@sherrylinks/sdk';
import { serialize } from 'wagmi';
import { encodeFunctionData, TransactionSerializable } from 'viem';
import { abi } from '@/blockchain/abi';

// Dirección del contrato en Avalanche Fuji Testnet
const CONTRACT_ADDRESS = '0xTuContratoInteligenteDirecciónAquí';
```

### 4. Construir el Handler POST del Contrato Inteligente

<Tabs>
<TabItem value="step1" label="Paso 1: Validación" default>

```typescript
export async function POST(req: NextRequest) {
  try {
    // Extraer entrada del usuario
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    // Validar parámetros requeridos
    if (!message) {
      return NextResponse.json(
        { error: 'Message parameter is required' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    // La lógica personalizada y creación de transacción se agregarán abajo
  } catch (error) {
    console.error('Error en petición POST:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
```

</TabItem>
<TabItem value="step2" label="Paso 2: Lógica Personalizada">

```typescript
export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    if (!message) {
      // Error de validación...
    }

    // LÓGICA DE NEGOCIO PERSONALIZADA: Calcular timestamp optimizado
    // Esto es lo que hace tu mini app única y valiosa
    const optimizedTimestamp = calculateOptimizedTimestamp(message);

    console.log(`Procesando mensaje: "${message}"`);
    console.log(`Timestamp optimizado: ${optimizedTimestamp}`);

    // La creación de transacción se agregará después
  } catch (error) {
    // Manejo de errores...
  }
}
```

</TabItem>
<TabItem value="step3" label="Paso 3: Transacción del Contrato">

```typescript
export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    if (!message) {
      // Validación...
    }

    const optimizedTimestamp = calculateOptimizedTimestamp(message);

    // Codificar los datos de la función del contrato
    const data = encodeFunctionData({
      abi: abi,
      functionName: 'storeMessage',
      args: [message, BigInt(optimizedTimestamp)],
    });

    // Crear transacción de interacción con contrato inteligente
    const tx: TransactionSerializable = {
      to: CONTRACT_ADDRESS,
      data: data,
      chainId: avalancheFuji.id,
      type: 'legacy',
    };

    // La serialización y respuesta se agregarán después
  } catch (error) {
    // Manejo de errores...
  }
}
```

</TabItem>
</Tabs>

<details>
<summary><strong>Entendiendo las Propiedades de Transacción de Contrato Inteligente</strong></summary>

- **to**: La dirección del contrato desplegado en la blockchain
- **data**: Los datos codificados de la función usando `encodeFunctionData`
- **chainId**: El ID numérico de la blockchain (avalancheFuji.id = 43113)
- **type**: El tipo de transacción ('legacy' para compatibilidad amplia)

</details>

### 5. Handler Completo de Contrato Inteligente

```typescript title="Handler POST Completo - Interacción con Contrato Inteligente"
export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    if (!message) {
      return NextResponse.json(
        { error: 'Message parameter is required' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    // Calcular timestamp optimizado usando algoritmo personalizado
    const optimizedTimestamp = calculateOptimizedTimestamp(message);

    // Codificar los datos de la función del contrato
    const data = encodeFunctionData({
      abi: abi,
      functionName: 'storeMessage',
      args: [message, BigInt(optimizedTimestamp)],
    });

    // Crear transacción de contrato inteligente
    const tx: TransactionSerializable = {
      to: CONTRACT_ADDRESS,
      data: data,
      chainId: avalancheFuji.id,
      type: 'legacy',
    };

    // Serializar transacción
    const serialized = serialize(tx);

    // Crear respuesta
    const resp: ExecutionResponse = {
      serializedTransaction: serialized,
      chainId: avalancheFuji.name,
    };

    return NextResponse.json(resp, {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    });
  } catch (error) {
    console.error('Error en petición POST:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
```

### 6. Implementar el Algoritmo Personalizado

```typescript title="Algoritmo Personalizado para Timestamp"
// Algoritmo personalizado para calcular timestamp optimizado basado en el contenido del mensaje
function calculateOptimizedTimestamp(message: string): number {
  const currentTimestamp = Math.floor(Date.now() / 1000);

  let offset = 0;

  for (let i = 0; i < message.length; i++) {
    offset += message.charCodeAt(i) * (i + 1);
  }

  const maxOffset = 3600;
  offset = offset % maxOffset;

  return currentTimestamp + offset;
}
```

## 🌐 Manejo de CORS

<Admonition type="warning" title="Configuración Esencial">
  **Es fundamental configurar CORS antes de probar o desplegar tu mini app**. Sin la configuración
  CORS correcta, tu mini app no funcionará cuando sea accedida desde plataformas externas como el
  debugger de Sherry o aplicaciones de terceros.
</Admonition>

Para permitir que tu mini app sea usada desde diferentes dominios y plataformas, necesitas manejar peticiones preflight de CORS:

```typescript title="Handler CORS OPTIONS"
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 204, // Sin Contenido
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers':
        'Content-Type, Authorization, X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Date, X-Api-Version',
    },
  });
}
```

<Admonition type="info" title="Por Qué Se Necesita OPTIONS">
  Cuando las plataformas intentan usar tu mini app desde un dominio diferente, los navegadores
  primero envían una **petición OPTIONS** para verificar si se permiten peticiones cross-origin.
  Este handler le dice al navegador que tu API acepta peticiones de cualquier dominio.
</Admonition>

### Headers CORS en Todas las Respuestas

Asegúrate de incluir los headers CORS en **todas** las respuestas de tu API:

```typescript title="Headers CORS Estándar"
headers: {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
}
```

## 🧪 Probando tu Mini App

### Opción 1: App Sherry Social

<div
  style={{
    padding: '1rem',
    backgroundColor: 'var(--ifm-color-info-contrast-background)',
    borderLeft: '4px solid var(--ifm-color-info)',
    borderRadius: '4px',
    margin: '1rem 0',
  }}
>
  <strong>Pruebas en Producción</strong>
  <ol>
    <li>
      Ve a{' '}
      <a href="https://app.sherry.social/home" target="_blank">
        https://app.sherry.social/home
      </a>
    </li>
    <li>En el campo de dirección, ingresa la URL de tu endpoint GET</li>
    <li>
      Ejemplo: <code>http://localhost:3000/api/mi-app</code> (para desarrollo local)
    </li>
    <li>La plataforma renderizará automáticamente tu mini app</li>
  </ol>
</div>

### Opción 2: Debugger de Sherry (Recomendado para Desarrollo)

<Admonition type="tip" title="Beneficios del Debugger">
  El debugger está específicamente diseñado para **probar y debuggear** mini apps durante el
  desarrollo con múltiples métodos de entrada.
</Admonition>

<Admonition type="warning" title="Importante: Despliega Primero en Producción">
  Para probar tu mini app en el debugger, **primero debes desplegarla** en un proveedor de hosting
  como Vercel. El debugger necesita una **URL pública accesible** para poder cargar tu mini app. Si
  quieres probar localmente, usa el método **JSON** copiando la respuesta de tu endpoint GET local y
  pegándola en el debugger.
</Admonition>

<Tabs>
<TabItem value="url" label="Prueba URL (Recomendado)" default>

1. **Despliega tu mini app en Vercel**:
   - `vercel --prod`
2. **Prueba URL**:
   - Pega la URL de tu endpoint GET desplegado
   - Ejemplo: `https://mi-sherry-app.vercel.app/api/mi-app`
   - Haz clic en "Cargar" para renderizar tu mini app

</TabItem>
<TabItem value="json" label="Prueba JSON (Para Testing Local)">

1. Ve a [https://app.sherry.social/debugger](https://app.sherry.social/debugger)
2. **Para testing local únicamente**:
   - Visita tu endpoint GET directamente: `http://localhost:3000/api/mi-app`
   - Copia toda la respuesta JSON
   - Pégala en la entrada JSON del debugger
   - Esto es útil para probar metadata durante desarrollo

</TabItem>
<TabItem value="typescript" label="Prueba TypeScript">

1. Copia tu objeto metadata de tu código TypeScript
2. Pégalo directamente en el debugger
3. Bueno para iteración rápida en la estructura de metadata

</TabItem>
</Tabs>

### Proceso de Pruebas Paso a Paso

1. **Desarrollar Localmente**

   - Ejecutar `npm run dev`
   - Probar en `localhost:3000/api/mi-app`

2. **Desplegar en Vercel**

   - `vercel --prod`
   - Obtener URL pública

3. **Probar en Debugger**

   - Usar URL pública del despliegue
   - Verificar renderizado completo

4. **Probar Funcionalidad**
   - Completar formulario y probar POST
   - Verificar transacción generada

## 🏆 Guías del Minithon

### Qué Hace una Presentación Ganadora del Minithon

<Tabs>
<TabItem value="technical" label="Requisitos Técnicos" default>

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
    gap: '1rem',
  }}
>
  <div style={{ padding: '1rem', border: '2px solid #10b981', borderRadius: '8px' }}>
    <h4>Interacción con Contratos Inteligentes</h4>
    <p>Funcionalidad significativa más allá de transferencias simples</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #10b981', borderRadius: '8px' }}>
    <h4>Lógica de Negocio Personalizada</h4>
    <p>Algoritmos únicos que agregan valor real</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #10b981', borderRadius: '8px' }}>
    <h4>Múltiples Parámetros</h4>
    <p>Manejo sofisticado de datos</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #10b981', borderRadius: '8px' }}>
    <h4>Manejo de Errores</h4>
    <p>Mensajes de error amigables para el usuario</p>
  </div>
</div>

</TabItem>
<TabItem value="creativity" label="Factores de Creatividad">

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
    gap: '1rem',
  }}
>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Casos de Uso Únicos</h4>
    <p>Que resuelvan problemas reales</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Algoritmos Innovadores</h4>
    <p>O procesamiento de datos</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Combinaciones de Parámetros Interesantes</h4>
    <p>Que aporten funcionalidad útil</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Aplicaciones Prácticas</h4>
    <p>Para usuarios reales</p>
  </div>
</div>

</TabItem>
<TabItem value="examples" label="Buenas Ideas">

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
    gap: '1rem',
  }}
>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Herramientas DeFi</h4>
    <p>
      Calculadoras de rendimiento personalizadas, rebalanceo de portafolio, estrategias
      automatizadas
    </p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Gaming</h4>
    <p>Mecánicas de juego on-chain, interacciones NFT, sistemas de puntuación</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Social</h4>
    <p>Mensajería descentralizada, sistemas de reputación, herramientas comunitarias</p>
  </div>
  <div
    style={{ padding: '1rem', border: '1px solid var(--ifm-color-primary)', borderRadius: '8px' }}
  >
    <h4>Productividad</h4>
    <p>Gestión de tareas con recompensas de tokens, herramientas colaborativas</p>
  </div>
</div>

</TabItem>
</Tabs>

### Qué No Será Aceptado en el Minithon

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
    gap: '1rem',
    margin: '1rem 0',
  }}
>
  <div style={{ padding: '1rem', border: '2px solid #dc2626', borderRadius: '8px' }}>
    <h4>Transferencias Simples de Tokens</h4>
    <p>Usa nuestro TransferAction en su lugar</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #dc2626', borderRadius: '8px' }}>
    <h4>Ejemplos Copiados y Pegados</h4>
    <p>Sin modificaciones significativas</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #dc2626', borderRadius: '8px' }}>
    <h4>Sin Contratos Inteligentes</h4>
    <p>Las mini apps deben interactuar con contratos</p>
  </div>
  <div style={{ padding: '1rem', border: '2px solid #dc2626', borderRadius: '8px' }}>
    <h4>Implementaciones Rotas</h4>
    <p>Deben funcionar de extremo a extremo</p>
  </div>
</div>

## 🔧 Resolución de Problemas

<Tabs>
<TabItem value="get-errors" label="Problemas del Endpoint GET" default>

### Error: "Falló la validación de metadata"

**Síntomas**: La mini app no carga en el debugger

<Admonition type="danger" title="Soluciones">
  - Verifica que todos los campos requeridos estén presentes en la metadata - Confirma que los tipos
  de datos coincidan con el formato esperado - Usa `createMetadata()` para validar la estructura -
  Revisa la consola para errores específicos de validación
</Admonition>

```typescript title="Debug de Metadata"
try {
  const validated = createMetadata(metadata);
  console.log('Validación de metadata exitosa:', validated);
} catch (error) {
  console.error('Falló la validación de metadata:', error);
}
```

### Error: "La política CORS bloquea la petición"

**Síntomas**: "El acceso a fetch ha sido bloqueado por la política CORS"

```typescript title="Headers CORS Correctos"
headers: {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
}
```

</TabItem>
<TabItem value="post-errors" label="Problemas del Endpoint POST">

### Error: "Parámetro requerido"

**Síntomas**: Error sobre parámetros faltantes

```typescript title="Debug de Parámetros"
console.log('Todos los parámetros:', Object.fromEntries(searchParams.entries()));
console.log('Parámetro mensaje:', searchParams.get('mensaje'));
```

### Error: "Falló la serialización de transacción"

**Síntomas**: Error durante la llamada serialize()

<Admonition type="caution" title="Correcciones Comunes">
  - Usa `BigInt(1000000)` no `1000000` para números grandes - Verifica que chainId sea correcto para
  la red objetivo - Asegúrate de que todos los campos requeridos de transacción estén presentes -
  Para llamadas a contratos, verifica que el ABI coincida con el contrato desplegado
</Admonition>

</TabItem>
<TabItem value="contract-errors" label="Problemas de Contratos Inteligentes">

### Error: "Función ABI no encontrada"

**Síntomas**: Error sobre función faltante o incorrecta

<Admonition type="info" title="Pasos de Verificación">
  - Verifica que el nombre de la función coincida exactamente con el contrato (sensible a
  mayúsculas) - Confirma que la función sea pública en el contrato inteligente - Asegúrate de que el
  ABI esté completo e incluya la función - Verifica que los tipos de parámetros coincidan con la
  firma de la función del contrato
</Admonition>

### Error: "Dirección de contrato inválida"

**Síntomas**: La transacción falla con errores relacionados a la dirección

- Verifica que el contrato esté desplegado en la red correcta (Fuji testnet)
- Confirma que la dirección esté correctamente formateada (comienza con 0x)
- Asegúrate de tener la dirección correcta del contrato para tu red
- Verifica que el contrato esté verificado en el explorador de blockchain

</TabItem>
</Tabs>

## 🚀 Ejemplo de Código Completo

Aquí tienes un archivo de ruta completo, **listo para minithon** que demuestra todos los conceptos:

````typescript title="app/api/mi-app/route.ts - Ejemplo Completo"
import { NextRequest, NextResponse } from 'next/server';
import { avalancheFuji } from 'viem/chains';
import { createMetadata, Metadata, ValidatedMetadata, ExecutionResponse } from '@sherrylinks/sdk';
import { serialize } from 'wagmi';
import { encodeFunctionData, TransactionSerializable } from 'viem';
import { abi } from '@/blockchain/abi';

const CONTRACT_ADDRESS = '0xTuContratoInteligenteEnFuji';

export async function GET(req: NextRequest) {
  try {
    const host = req.headers.get('host') || 'localhost:3000';
    const protocol = req.headers.get('x-forwarded-proto') || 'http';
    const serverUrl = `${protocol}://${host}`;

    const metadata: Metadata = {
      url: 'https://sherry.social',
      icon: 'https://avatars.githubusercontent.com/u/117962315',
      title: 'Mensaje con Timestamp',
      baseUrl: serverUrl,
      description:
        'Almacena un mensaje con un timestamp optimizado calculado por nuestro algoritmo',
      actions: [
        {
          type: 'dynamic',
          label: 'Almacenar Mensaje',
          description:
            'Almacena tu mensaje con un timestamp personalizado calculado para almacenamiento óptimo',
          chains: { source: 'fuji' },
          path: `/api/mi-app`,
          params: [
            {
              name: 'mensaje',
              label: '¡Tu Mensaje Hermano!',
              type: 'text',
              required: true,
              description: 'Ingresa el mensaje que quieres almacenar en la blockchain',
            },
          ],
        },
      ],
    };

    const validated: ValidatedMetadata = createMetadata(metadata);

    return NextResponse.json(validated, {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      },
    });
  } catch (error) {
    return NextResponse.json({ error: 'Error al crear metadata' }, { status: 500 });
  }
}

export async function POST(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const message = searchParams.get('mensaje');

    if (!message) {
      return NextResponse.json(
        { error: 'Message parameter is required' },
        {
          status: 400,
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          },
        },
      );
    }

    // Lógica de negocio personalizada
    const optimizedTimestamp = calculateOptimizedTimestamp(message);

    // Interacción con contrato inteligente
    const data = encodeFunctionData({
      abi: abi,
      functionName: 'storeMessage',
      args: [message, BigInt(optimizedTimestamp)],
    });

    const tx: TransactionSerializable = {
      to: CONTRACT_ADDRESS,
      data: data,
      chainId: avalancheFuji.id,
      type: 'legacy',
    };

    const serialized = serialize(tx);

    const resp: ExecutionResponse = {
      serializedTransaction: serialized,
      chainId: avalancheFuji.name,
    };

    return NextResponse.json(resp, {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    });
  } catch (error) {
    console.error('Error en petición POST:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

=======
## Creando el Endpoint POST - Ejecución

El endpoint POST maneja la ejecución real de tu mini app. Recibe los parámetros
del usuario y devuelve una transacción serializada.

### 1. Configurar el Handler POST

```typescript
import { avalancheFuji } from "viem/chains";
import { ExecutionResponse } from "@sherrylinks/sdk";
import { serialize } from 'wagmi';

export async function POST(req: NextRequest) {
    try {
        // Obtener parámetros de la URL
        const { searchParams } = new URL(req.url);
        const mensaje = searchParams.get("mensaje");
        const cantidad = searchParams.get("cantidad");

        // Validar parámetros requeridos
        if (!mensaje) {
            return NextResponse.json(
                { error: "El parámetro 'mensaje' es requerido" },
                {
                    status: 400,
                    headers: {
                        "Access-Control-Allow-Origin": "*",
                        "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
                        "Access-Control-Allow-Headers": "Content-Type, Authorization",
                    },
                }
            );
        }
````

### 2. Procesar los Datos y Crear la Transacción

```typescript
// Procesar los datos (aquí puedes agregar tu lógica de negocio)
console.log('Mensaje recibido:', mensaje);
console.log('Cantidad recibida:', cantidad);

// Crear la transacción
const tx = {
  to: '0x5ee75a1B1648C023e885E58bD3735Ae273f2cc52', // Dirección destino
  value: BigInt(cantidad ? parseFloat(cantidad) * 1e18 : 1000000), // Valor en wei
  chainId: avalancheFuji.id, // ID de la blockchain
  // data: "0x..." // Puedes agregar datos de contrato aquí
};
```

### 3. Serializar y Retornar la Transacción

```typescript
        // Serializar la transacción
        const serializedTx = serialize(tx);

        // Crear la respuesta
        const response: ExecutionResponse = {
            serializedTransaction: serializedTx,
            chainId: avalancheFuji.name, // Nombre de la chain
        };

        return NextResponse.json(response, {
            status: 200,
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
                "Access-Control-Allow-Headers": "Content-Type, Authorization",
            },
        });

    } catch (error) {
        console.error("Error en POST:", error);
        return NextResponse.json(
            { error: "Error interno del servidor" },
            { status: 500 }
        );
    }
}
```

## Manejo de CORS

Para permitir que tu mini app sea utilizada desde diferentes dominios, necesitas
manejar las peticiones OPTIONS:

```typescript
>>>>>>> develop
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers':
<<<<<<< HEAD
        'Content-Type, Authorization, X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Date, X-Api-Version',
    },
  });
}

// Algoritmo personalizado - aquí es donde agregas tu valor único
function calculateOptimizedTimestamp(message: string): number {
  const currentTimestamp = Math.floor(Date.now() / 1000);

  let offset = 0;

  for (let i = 0; i < message.length; i++) {
    offset += message.charCodeAt(i) * (i + 1);
  }

  const maxOffset = 3600;
  offset = offset % maxOffset;

  return currentTimestamp + offset;
}
```

## 📚 Repositorio de Ejemplos

<Admonition type="info" title="Ejemplos Completos Disponibles">
  Puedes encontrar ejemplos completos de trabajo en nuestro repositorio:
  [SherryLabs/sherry-example](https://github.com/SherryLabs/sherry-example)
</Admonition>

Este repositorio contiene:

- Tanto ejemplos de transferencia simple como de contrato inteligente
- Código completo de contrato inteligente con fuente Solidity
- Scripts de despliegue y configuración
- Archivos ABI e instrucciones de configuración
- Ejemplos de múltiples parámetros
- Utilidades avanzadas de prueba
- Documentación completa

## 🎯 Próximos Pasos

<Tabs>
<TabItem value="learning" label="Para Aprender" default>

1. **Comienza con el ejemplo de transferencia simple** para entender el flujo
2. **Pasa al ejemplo de contrato inteligente** una vez que te sientas cómodo
3. **Experimenta con diferentes** tipos de parámetros y validaciones
4. **Prueba minuciosamente** usando el debugger

</TabItem>
<TabItem value="minithon" label="Para Participantes del Minithon">

1. **Omite la transferencia simple** - ve directamente a la interacción con contratos inteligentes
2. **Diseña tu algoritmo único** - ¿qué problema vas a resolver?
3. **Planifica tu contrato inteligente** - ¿qué funciones y datos necesitas?
4. **Crea múltiples parámetros** - hazlo sofisticado y útil
5. **Prueba extensivamente** - asegúrate de que todo funcione perfectamente
6. **Documenta tu innovación** - explica por qué tu solución es única

</TabItem>
<TabItem value="deployment" label="Consideraciones de Despliegue">

- **Desarrollo Local**: Usa `http://localhost:3000` para pruebas
- **Producción**: Despliega en Vercel con `vercel --prod`
- **Dominios Personalizados**: Actualiza las URLs de tu metadata para coincidir con tu dominio
- **Variables de Entorno**: Almacena datos sensibles como claves privadas de forma segura
- **Redes de Prueba**: Comienza con Fuji testnet, luego pasa a mainnet

</TabItem>
</Tabs>

---

<div
  style={{
    textAlign: 'center',
    padding: '2rem',
    backgroundColor: 'var(--ifm-color-primary-contrast-background)',
    borderRadius: '8px',
    margin: '2rem 0',
  }}
>
  <h2>🚀 ¿Listo para Construir Algo Increíble?</h2>
  <p>
    Recuerda, la clave para un envío exitoso al minithon no es solo hacer que funcione, sino hacerlo{' '}
    <strong>útil</strong>, <strong>innovador</strong> y <strong>técnicamente impresionante</strong>.
    Enfócate en resolver problemas reales con soluciones creativas que demuestren el poder de la
    tecnología blockchain combinada con una gran experiencia de usuario.
  </p>
  <p>
    <strong>¡Buena suerte con el desarrollo de tu mini app y el envío al minithon! 🏆</strong>
  </p>
</div>
======= 'Content-Type, Authorization, X-CSRF-Token, X-Requested-With, Accept', }, }); } ```

## Probando tu Mini App

Una vez que hayas creado tu endpoint GET, tienes varias opciones para probar tu
mini app:

### Opción 1: Sherry Social App

1. Ve a [https://app.sherry.social/home](https://app.sherry.social/home)
2. En el campo de dirección, ingresa la URL de tu endpoint GET
3. Ejemplo: `http://localhost:3000/api/mi-app` (para desarrollo local)
4. La plataforma renderizará automáticamente tu mini app

### Opción 2: Debugger de Sherry (Recomendado para Desarrollo)

El debugger te permite probar tu mini app de múltiples maneras:

1. Ve a [https://app.sherry.social/debugger](https://app.sherry.social/debugger)

2. **Opción A - URL**: Pega la URL de tu endpoint GET
3. **Opción B - JSON**: Copia y pega la respuesta JSON de tu endpoint
4. **Opción C - TypeScript**: Pega directamente tu código TypeScript

**Nota**: El debugger está en desarrollo y puede tener bugs. Puedes reportar
problemas directamente desde la interfaz del debugger.

### Pasos para Probar:

1. **Inicia tu servidor de desarrollo**:

   ```bash
   npm run dev
   ```

2. **Verifica tu endpoint GET**:

   - Ve a `http://localhost:3000/api/mi-app`
   - Deberías ver la metadata JSON

3. **Prueba en el debugger**:

   - Usa la URL: `http://localhost:3000/api/mi-app`
   - Verifica que se rendericen correctamente los campos de entrada
   - Prueba completar el formulario y enviar

4. **Verifica la ejecución**:
   - Completa los campos requeridos
   - Haz clic en el botón de acción
   - Deberías recibir una transacción serializada

## Resolución de Problemas

### Error: "CORS policy"

- Asegúrate de que todos tus endpoints incluyan los headers CORS correctos
- Verifica que el método OPTIONS esté implementado

### Error: "Metadata validation failed"

- Revisa que todos los campos requeridos estén presentes
- Verifica que los tipos de datos sean correctos
- Usa `createMetadata()` para validar tu metadata

### Error: "Parameter required"

- Asegúrate de que los parámetros requeridos estén marcados como
  `required: true`
- Verifica que los nombres de los parámetros coincidan entre la metadata y el
  POST

### La mini app no se renderiza correctamente

- Verifica que la URL de tu endpoint GET sea accesible públicamente
- Revisa la consola del navegador para errores de JavaScript
- Asegúrate de que el JSON de respuesta sea válido

### Errores de serialización de transacciones

- Verifica que los valores estén en el formato correcto (BigInt para valores de
  wei)
- Asegúrate de que el chainId sea válido
- Revisa que la dirección 'to' sea una dirección Ethereum válida

## Código de Ejemplo

### Español

Puedes encontrar un ejemplo completo de este tutorial en el siguiente
repositorio:
[https://github.com/SherryLabs/sherry-example](https://github.com/SherryLabs/sherry-example)

Este repositorio contiene todo el código necesario para implementar una mini app
funcional usando Next.js y Sherry SDK.

---

¡Felicidades! Ya tienes tu primera mini app funcionando con Sherry SDK. Puedes
expandir la funcionalidad agregando más parámetros, validaciones personalizadas,
o integrando con contratos inteligentes más complejos.

> > > > > > > develop
